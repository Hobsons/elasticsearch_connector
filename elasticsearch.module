<?php
/**
 * @file
 * This module provide an interface to connecting to the elasticsearch
 * cluster and implementing the Elastica library.
 *
 * Created on Dec 21, 2013
 */

define('ELASTICSEARCH_CLUSTER_STATUS_OK', '200');

use Symfony\Component\HttpFoundation\Request;

/**
 * Implements hook_help().
 */
function elasticsearch_help($route_name, Request $request) {
  switch ($route_name) {
    case 'admin/help#elasticsearch':
      return '<p>' . t('Abstraction of making connection to the elasticsearch
        server. This module is API for a whole bunch of functionality connected
        with this module."') . '</p>';
  }
}

/**
 * Implements hook_cron()
 */
function elasticsearch_cron() {
  // TODO: Check cluster node state and update cluster nodes if any changes.
  // Do this only if we have auto-node update configuration enabled.
  // The default state of the auto mode will be activeated!
}

/**
 * Implements hook_permission().
 */
function elasticsearch_permission() {
  return array(
    'adminiser elasticsearch' => array(
      'title' => t('Administer elasticsearch'),
      'description' => t('Giving you access to administer elasticsearch clusters.'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function elasticsearch_theme() {
  return array(
    'elasticsearch_page' => array(
      'render element' => 'page',
      'template' => 'elasticsearch-dialog-page',
    ),
  );
}

/**
 * Implements hook_menu().
 */
// TODO
function elasticsearch_menu() {
  $items = array();

  $items[$settings_path] = array(
    'title'              => 'Elasticsearch',
    'description'        => 'Administer Elasticsearch module',
    'position'           => 'left',
    'access arguments'   => array('administer elasticsearch'),
    'page callback'      => 'system_admin_menu_block_page',
    'file'               => 'system.admin.inc',
    'file path'          => drupal_get_path('module', 'system'),
  );

  $items['elasticsearch/clusters'] = array(
    'title'             => 'Elasticsearch Clusters',
    'description'       => 'Showing all available clusters',
    'route_name'        => 'elasticsearch.clusters',
  );

  $items[$settings_path . '/clusters/add'] = array(
    'title'              => 'Add cluster',
    'description'        => 'Add new elasticsearch cluster',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('elasticsearch_edit_cluster'),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
    'type'               => MENU_LOCAL_ACTION,
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/edit'] = array(
    'title'              => 'Edit cluster',
    'description'        => 'Edit cluster settings',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('elasticsearch_edit_cluster', 4),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
    'type'               => MENU_CALLBACK,
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/info'] = array(
    'title'              => 'Elasticsearch cluster info',
    'description'        => 'Elasticsearch cluster info',
    'page callback'      => 'elasticsearch_info_cluster',
    'page arguments'     => array(4),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
    'type'               => MENU_CALLBACK,
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/indices'] = array(
    'title'              => 'Elasticsearch cluster indices',
    'description'        => 'Elasticsearch cluster indices',
    'page callback'      => 'elasticsearch_cluster_indices',
    'page arguments'     => array(4),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/indices/add'] = array(
    'title'              => 'Add index',
    'description'        => 'Add index',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('elasticsearch_cluster_indices_add', 4),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
    'type'               => MENU_LOCAL_ACTION,
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/indices/%elasticsearch_index_valid/aliases'] = array(
    'title'              => 'Elasticsearch cluster indices',
    'description'        => 'Elasticsearch cluster indices',
    'page callback'      => 'elasticsearch_cluster_indices_aliases',
    'page arguments'     => array(4, 6),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/indices/%elasticsearch_index_valid/delete'] = array(
    'title'              => 'Elasticsearch cluster indices',
    'description'        => 'Elasticsearch cluster indices',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('elasticsearch_cluster_indices_delete', 4, 6),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
  );

  $items[$settings_path . '/clusters/%elasticsearch_cluster/delete'] = array(
    'title'              => 'Delete cluster',
    'description'        => 'Delete cluster settings',
    'page callback'      => 'drupal_get_form',
    'page arguments'     => array('elasticsearch_delete_cluster', 4),
    'access arguments'   => array('administer elasticsearch'),
    'file'               => 'elasticsearch.admin.inc',
  );

  $items['elasticsearch-dialog/redirect/%elasticsearch_cluster/%elasticsearch_index_valid'] = array(
    'page callback' => 'elasticsearch_redirect_page',
    'page arguments' => array(2, 3),
    'access arguments' => array('administer elasticsearch'),
  );

  return $items;
}

/**
 * Implements hook_element_info()
 */
function elasticsearch_element_info() {
  return array(
    'ec_clusters' => array(
      '#input' => TRUE,
      '#multiple' => FALSE,
      '#theme' => 'select',
      '#theme_wrappers' => array('form_element'),
      '#process' => array('_elasticsearch_ec_clusters_process'),
    ),
    'ec_index' => array(
      '#input' => TRUE,
      '#tree' => TRUE,
      '#multiple' => FALSE,
      '#theme_wrappers' => array('form_element'),
      '#process' => array('_elasticsearch_ec_index_process'),
      '#attached' => _elasticsearch_ec_index_attached(),
    ),
  );
}

/**
 * Process the ec_cluster element type.
 *
 * @param array $element
 * @return array $element
 */
function _elasticsearch_ec_clusters_process($element, &$form_state, $form) {
  $element = form_process_select($element);

  if (empty($element['#skip_default_options'])) {
    $element['#only_active'] = isset($element['#only_active']) ? $element['#only_active'] : TRUE;
    $element['#empty_option'] = isset($element['#empty_option']) ? $element['#empty_option'] : TRUE;
    $clusters = elasticsearch_cluster_load_all($element['#only_active'], $element['#empty_option']);
    $element['#options'] = $clusters;
  }

  return $element;
}

/**
 * Attach required javascript for the ec_index element.
 * @return array
 */
function _elasticsearch_ec_index_attached() {
  return array(
    'js' => array(drupal_get_path('module', 'elasticsearch') . '/js/ec-index.js'),
    'css' => array(drupal_get_path('module', 'elasticsearch') . '/css/ec-index.css'),
    'library' => array(array('system', 'ui.dialog')),
  );
}

/**
 * Check if some of the modules locked a major changes on the cluster settings and deletion.
 * Invoke the hooks similar to the module_invoke.
 *
 * @param object $cluster
 * @return array
 */
function _elasticsearch_check_if_cluster_locked($cluster) {
  $locked = array();
  if (!empty($cluster)) {
    $type = 'cluster';
    foreach(module_implements('elasticsearch_edit_lock') as $module) {
      $function = $module . '_elasticsearch_edit_lock';
      $locked_result = $function($type, $cluster, NULL);
      if (!empty($locked_result)) {
        $locked[] = $module;
      }
    }
  }

  return $locked;
}

/**
 * Check if some of the modules locked a major changes on the cluster settings and deletion.
 * @param string $cluster
 * @return array
 */
function _elasticsearch_check_if_index_locked($cluster, $index) {
  $locked = array();
  if (!empty($cluster)) {
    $type = 'index';
    foreach(module_implements('elasticsearch_edit_lock') as $module) {
      $function = $module . '_elasticsearch_edit_lock';
      $locked_result = $function($type, $cluster, $index);
      if (!empty($locked_result)) {
        $locked[] = $module;
      }
    }
  }

  return $locked;
}

/**
 * Implements hook_elasticsearch_edit_lock().
 */
function elasticsearch_elasticsearch_edit_lock($type, $cluster, $index = NULL) {
  if ($type == 'cluster' && $cluster->cluster_id == elasticsearch_get_default()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Build two dropdowns, one for the cluster and one for the indices.
 * @param array $element
 * @return arrat $element
 */
function _elasticsearch_ec_index_process($element, &$form_state, $form) {
  $element['#tree'] = TRUE;
  $element_id = $element['#id'];
  $wrapper_id = $element_id . '-index-wrapper';

  // TODO: Add icon if the cluster is OK or not.

  $element['cluster_id'] = array(
    '#type' => 'select',
    '#id' => $element_id . '-cluster-id',
    '#title' => t('Select cluster'),
    '#required' => $element['#required'],
    '#default_value' => isset($element['#default_value'])
                    && is_array($element['#default_value'])
                    && isset($element['#default_value']['cluster_id'])
                    ? $element['#default_value']['cluster_id'] : '',
    // TODO: Allow this option to be overwritten and #value if we had such.
    '#description' => t('Select the cluster.'),
    '#ajax' => array(
      'callback' => '_elasticsearch_ec_index_ajax',
      'wrapper' => $wrapper_id,
      'method' => 'replace',
      'effect' => 'fade',
    )
  );

  if (!isset($element['cluster_id']['#current_path'])) {
    $element['cluster_id']['#current_path'] = current_path();
  }

  if (empty($element['#skip_default_options'])) {
    $element['#only_active'] = isset($element['#only_active']) ? $element['#only_active'] : TRUE;
    $element['#empty_option'] = isset($element['#empty_option']) ? $element['#empty_option'] : TRUE;
    $clusters = elasticsearch_cluster_load_all($element['#only_active'], $element['#empty_option']);
    $element['cluster_id']['#options'] = $clusters;
  }

  // TODO: We need to handle the incomming tree name if such.
  $links = array();
  $index_options = array('' => t('Select index'));
  if (is_array($element['#value']) && !empty($element['#value']['cluster_id'])) {
    $index_options = array();
    try {
      $index_options = elasticsearch_get_indices_options($element['#value']['cluster_id'], TRUE);
    }
    catch (Exception $e) {
      if (!empty($element['#throw_exp'])) {
        throw $e;
      }
    }
    $links[] = array(
      'title' => t('Add index'),
      'href' => 'admin/config/elasticsearch-connector/clusters/' . $element['#value']['cluster_id'] . '/indices/add',
      'attributes' => array('target' => '_blank', 'class' => 'ec-index-dialog'),
      'query' => array(
        'render' => 'elasticsearch-dialog',
        'index_element_id' => $element_id . '-index',
        'cluster_element_id' => $element_id . '-cluster-id'
      )
    );
  }

  $element['index'] = array(
    '#type' => 'select',
    '#title' => t('Select index'),
    '#id' => $element_id . '-index',
    '#required' => $element['#required'],
    '#default_value' => isset($element['#default_value'])
                    && is_array($element['#default_value'])
                    && isset($element['#default_value']['index'])
                    ? $element['#default_value']['index'] : '',
    '#description' => t('Select the index.'),
    '#options' => $index_options,
    '#prefix' => '<div id="' . $wrapper_id . '">',
    '#suffix' =>'<div class="dialog-links ' . $element['#id'] . '">'
        . theme('links__es_index_links', array(
            'links' => $links,
            'attributes' => array('class' => 'index-dialog-links')
          ))
        . '</div></div>'
  );

  unset($element['#title']);
  $context = array(
    'form' => $form,
  );
  drupal_alter('ec_index_process', $element, $form_state, $context);

  return $element;
}

/**
 * Implements hook_page_alter().
 */
function elasticsearch_page_alter(&$page) {
  if (elasticsearch_in_dialog()) {
    unset($page['page_top']);
    unset($page['page_bottom']);

    $page['#theme'] = 'elasticsearch_page';
  }
}

/**
 * Check if we are in a references dialog.
 * @return boolean if we are in a dialog.
 */
function elasticsearch_in_dialog() {
  return (isset($_GET['render']) && $_GET['render'] == 'elasticsearch-dialog');
}

/**
 * Check if we should close the dialog upon submition.
 */
function elasticsearch_close_on_submit() {
  return (!isset($_GET['closeonsubmit']) || $_GET['closeonsubmit']);
}

/**
 * Sets our destination parameter so that the dialog will close itself after
 * redirect is completed.
 */
function elasticsearch_close_on_redirect($cluster_id, $index_name) {
  // We use $_GET['destination'] since that overrides anything that happens
  // in the form. It is a hack, but it is very effective, since we don't have
  // to be worried about getting overrun by other form submit handlers.
  $_GET['destination'] = 'elasticsearch-dialog/redirect/' .
      $cluster_id . '/' . $index_name .
      '?elasticsearch-dialog-close=1&render=elasticsearch-dialog';

  if (isset($_GET['cluster_element_id'])) {
    $_GET['destination'] .= '&index_element_id=' . $_GET['index_element_id'];
  }

  if (isset($_GET['cluster_element_id'])) {
    $_GET['destination'] .= '&cluster_element_id=' . $_GET['cluster_element_id'];
  }

}

/**
 * Page callback for our redirect page.
 */
function elasticsearch_redirect_page($cluster, $index_name) {
  // Add appropriate javascript that will be used by the parent page to
  // fill in the required data.
  if (elasticsearch_in_dialog() && isset($_GET['elasticsearch-dialog-close'])) {
    drupal_add_js(drupal_get_path('module', 'elasticsearch') . '/js/ec-index-child.js');
    drupal_add_js(array(
    'elasticsearch' =>
      array(
        'dialog' => array(
          'cluster_id' => $cluster->cluster_id,
          'index_name' => $index_name,
          'index_element_id' => (string)$_GET['index_element_id'],
          'cluster_element_id' => (string)$_GET['cluster_element_id'],
        ),
      )
    ), 'setting');
  }

  return '';
}

/**
 * ec_index element ajax callback.
 * @param array $form
 * @param array $form_state
 */
function _elasticsearch_ec_index_ajax($form, $form_state) {
  $element_name = $form_state['triggering_element']['#name'];
  $parents = $form_state['triggering_element']['#parents'];
  $search_key = array_search('cluster_id', $parents);
  $parents[$search_key] = 'index';
  $index_element = drupal_array_get_nested_value($form, $parents);

  return $index_element;
}

/**
 * Return the main path of the elasticsearch module.
 * @return string
 */
function elasticsearch_main_settings_path() {
  $settings_path = 'admin/config/elasticsearch-connector';
  return $settings_path;
}

/**
 * Return the basic breadcrumb for the module.
 * @param array $links
 */
function elasticsearch_set_breadcrumb($links = array()) {
  $breadcrumb = array(
    l(t('Home'), '<front>'),
    l(t('Administration'), 'admin'),
    l(t('Configuration'), 'admin/config'),
    l(t('Elasticsearch'), elasticsearch_main_settings_path()),
  );

  if (!empty($links)) {
    foreach ($links as $link) {
      $breadcrumb[] = $link;
    }
  }

  drupal_set_breadcrumb($breadcrumb);
}

/**
 * Save a cluster configuration object.
 *
 * @param stdclass $cluster
 *   The ElasticSearch cluster configuration object. This object should be
 *   loaded with elasticsearch_cluster_load() or
 *   elasticsearch_cluster_load_all()--otherwise, it is assumed to be
 *   a new configuration.
 */
// TODO in src/
function elasticsearch_cluster_save($cluster) {
  //ctools_include('export');

  $cluster = (object) $cluster;
  $cluster->options = serialize($cluster->options);

  if (isset($cluster->export_type) && $cluster->export_type & EXPORT_IN_DATABASE) {
    // Record exists in the database.
    $result = drupal_write_record('elasticsearch_cluster', $cluster, 'cluster_id');
  }
  else {
    // Record is new, or exists only in code.
    $result = drupal_write_record('elasticsearch_cluster', $cluster);
  }
}

/**
 * Delete an ElasticSearch cluster.
 *
 * @param stdclass $cluster
 *   A cluster configuration object.
 */
// TODO in src/
function elasticsearch_cluster_delete($cluster) {
  db_delete('elasticsearch_cluster')
    ->condition('cluster_id', $cluster->cluster_id)
    ->execute();
}

/**
 * Get the indeces based on cluster id.
 * @param string $cluster_id
 * @return array Indices
 */
// TODO in src
function elasticsearch_get_indices_options($cluster_id, $empty_option = FALSE) {
  $result = array();

  $client = elasticsearch_get_client_by_id($cluster_id);
  if ($client) {
    $indices = $client->indices()->stats();
    drupal_alter('elasticsearch_indices', $indices);
    if ($empty_option) {
      $result[''] = t('Select index');
    }
    if (!empty($indices['indices'])) {
      foreach ($indices['indices'] as $index_name => $index_info) {
        // TODO: Check index status if such e.g. index closed or s.o.
        $result[$index_name] = $index_name;
      }
    }
  }

  return $result;
}

/**
 * Load a cluster object from the database.
 *
 * @see ctools_export_load_object().
 *
 * @param string $cluster_id
 * @return object $cluster
 */
// Removed. Called from src/Entity/Cluster::loadCluser
function elasticsearch_cluster_load($cluster_id) {
  //ctools_include('export');
  //$result = ctools_export_load_object('elasticsearch_cluster', 'names', array($cluster_id));
  if (isset($result[$cluster_id])) {
    if (isset($result[$cluster_id]->options) && !is_array($result[$cluster_id]->options)) {
      $result[$cluster_id]->options = unserialize($result[$cluster_id]->options);
    }
    return $result[$cluster_id];
  }
}

/**
 * Check if the index name has been passed correctly.
 *
 * @param string $index_name
 * @return string boolean
 */
// TODO in src/
function elasticsearch_index_valid_load($index_name) {
  if (preg_match('/^[a-z][a-z0-9_]*$/i', $index_name)) {
    return $index_name;
  }

  return FALSE;
}

/**
 * Load all cluster objects.
 *
 * @param bool $include_inactive
 *   Included inactive clusters. Defaults to true.
 *
 * @return array
 *   An array of ElasticSearch connection cluster objects.
 */
function loadAllClusters($include_inactive = TRUE) {
  // TODO: Remove ctools
  //ctools_include('export');
  //$clusters = ctools_export_load_object('elasticsearch_cluster', 'all');

  // Filter out inactive clusters.
  foreach ($clusters as $cluster_id => $cluster) {
    // Unserialize the options if they are loaded from database.
    // If they are loaded from exported object it will be array.
    if (isset($cluster->options) && !is_array($cluster->options)) {
      $cluster->options = unserialize($cluster->options);
    }
    if (!$include_inactive && !$cluster->status) {
      unset($clusters[$cluster_id]);
    }
  }

  return $clusters;
}

/**
 * Prepare list of all clusters by status.
 *
 * @param bool $active
 *   Flag to return clusters with certain status.
 * @param bool $add_empty_option
 *   Flag whether to add empty option to the list.
 *
 * @return array
 *   An array of ElasticSearch connection cluster names, indexed by id.
 */
function loadCluserByStatus($active = TRUE, $add_empty_option = FALSE) {
  $clusters = elasticsearch_clusters($active);
  $options = array();

  if ($add_empty_option) {
    $options[''] = t('None');
  }

  foreach ($clusters as $cluster) {
    $options[$cluster->cluster_id] = $cluster->name;
  }

  return $options;
}

/**
 *
 * @param string $url
 * @return
 */
// Removed. Called from src/Entitiy/Cluster::getClusterByUrls
function elasticsearch_load_library($cluster) {
  static $clients;

  if (!isset($clients[$cluster->cluster_id])) {
    $clients[$cluster->cluster_id] = FALSE;

    // TODO: Handle cluster connection. This should be accomplished if the setting is enabled.
    // If enabled, discover all the nodes in the cluster initialize the Pool connection.
    if (valid_url($cluster->url)) {
      $options = array(
        'hosts' => array($cluster->url),
      );
      drupal_alter('elasticsearch_load_library_options', $options);
      try {
        if (!class_exists('\Elasticsearch\Client') && module_exists('composer_manager')) {
          // If the class doesn't exists try to explicity load the classes!
          // The issues is in update.php where search api call this function, but the function
          // has not been invoked.
          composer_manager_register_autoloader();
        }
        $clients[$cluster->cluster_id] = new \Elasticsearch\Client($options);
      }
      catch (Exception $e) {
        drupal_set_message($e->getMessage(), 'error');
      }
    }
  }

  return $clients[$cluster->cluster_id];
}

/**
 * Check if the REST response is successful and with status code 200.
 * @param array $response
 * @return boolean
 */
function elasticsearch_check_response_ack($response) {
  if (is_array($response) && !empty($response['acknowledged'])) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Get the nodes stats from elasticsearch server.
 * @param \Elasticsearch\Client $client
 * @return array
 */
function elasticsearch_get_cluster_nodes_stat(\Elasticsearch\Client $client) {
  try {
    return $client->nodes()->stats();
  }
  catch (Exception $e) {
      drupal_set_message($e->getMessage(), 'error');
    }
}

/**
 * Check if a specific plugin exists on all nodes.
 * TODO: This should be changed to check all data Nodes only but for now lets check all of them.
 *
 * Read more about pluggins system here:
 * http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-plugins.html
 *
 * @param \Elasticsearch\Client $client
 * @param string $plugin
 * @return boolean
 */
function elasticsearch_check_plugin_exists(\Elasticsearch\Client $client, $plugin_name) {
  $nodes_plugins = array();
  $result = FALSE;

  try {
    $plugins = $client->nodes()->info(array('node_id' => '_all'));
    foreach ($plugins['nodes'] as $elastic_node_id => $elastic_node) {
      $nodes_plugins[$elastic_node_id][$plugin_name] = FALSE;
      foreach($elastic_node['plugins'] as $plugin) {
        if ($plugin['name'] == $plugin_name) {
          $nodes_plugins[$elastic_node_id][$plugin_name] = TRUE;
        }
      }

      if (empty($nodes_plugins[$elastic_node_id][$plugin_name])) {
        $result = FALSE;
        break;
      }
      else {
        $result = TRUE;
      }
    }

    return $result;
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    return FALSE;
  }
}

/**
 * Process variables for references_dialog_page.
 */
function template_process_elasticsearch_page(&$variables) {
  // Generate messages last in order to capture as many as possible for the
  // current page.
  if (!isset($variables['messages'])) {
    $variables['messages'] = $variables['page']['#show_messages'] ? theme('status_messages') : '';
  }
}


/**
 * Helper function you can use with #element_validate of any form element
 * you want to be validated as Elasticsearch TTL setting.
 *
 * @param array $element
 * @param array $form_state
 * @param array $form
 * @return void
 */
function _elasticsearch_validate_ttl_field($element, &$form_state, $form) {
  if (!empty($element['#value']) && !preg_match('/^([\d]+)(d|m|h|ms|w)$/', $element['#value'])) {
    form_error($element, t('Invalid elasticsearch TTL value. Please use the proper syntax e.g. 1d (d (days), m (minutes), h (hours), ms (milliseconds) or w (weeks)).'));
  }
}
